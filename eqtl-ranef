#!/usr/bin/env Rscript

##
## MODEL FITTING FUNCTIONS
##
DRIVERS <-
    list(

        DEFAULT = list(fitter = function(dat) {
          tryCatch({
            B <- coefficients(summary(lmer(formula, data = dat)))
            out <- B["alleleCopyNumber",, drop = FALSE]
            tValue <- out[, "t value"]
            subset(data.frame(pvalue = 2 * pnorm(abs(tValue), lower.tail = FALSE),
                              beta = out[, "Estimate"],
                              t = tValue,
                              nobs = nrow(dat)),
                   pvalue <= pvalue.max)
          }, error = function(e) {
            return(NULL)
          })
        },
            colnames = c("pvalue", "beta", "t", "nobs")),

        INTERACTIONS = list(fitter = function(dat) {
          tryCatch({

            fit.full <- lmer(formula, data = dat) ## including interaction terms
            fit.base <- lmer(formula.baseline, data = dat) ## main effects only

            fit.compare <- anova(fit.base, fit.full)

            B <- coefficients(summary(fit.full))
            copyNumberTerms <- grep("^alleleCopyNumber", rownames(B), value = TRUE)
            interactionTerms <- sub("^alleleCopyNumber:", ":", copyNumberTerms)
            out <- B[copyNumberTerms,, drop = FALSE]
            tValue <- out[, "t value"]

            ans <- data.frame(pvalue = 2 * pnorm(abs(tValue), lower.tail = FALSE),
                              beta = out[, "Estimate"],
                              t = tValue,
                              nobs = nrow(dat),
                              interactionTerm = interactionTerms,
                              stringsAsFactors = FALSE)

            ans <- rbind(ans,
                         data.frame(pvalue = fit.compare$`Pr(>Chisq)`[2],
                                    beta = NA_real_,
                                    t = fit.compare$Chisq[2],
                                    nobs = nrow(dat),
                                    interactionTerm = "anyInteraction",
                                    stringsAsFactors = FALSE))

            subset(ans, pvalue <= pvalue.max)
          }, error = function(e) {
            stop(e)
            return(NULL)
          })
        },
            colnames = c("pvalue", "beta", "t", "nobs", "interactionTerm"))

        )

DRIVER <- DRIVERS$DEFAULT

suppressMessages({
  library(optparse)
  library(reshape)
  library(plyr)
  library(RSQLite)
  library(lme4)
})

option_list <-
    list(
        make_option("--regressors", help = "regressors data matrix file (use '-' for standard input)", default = NULL),
        make_option("--outcomes", help = "outcomes data matrix file", default = NULL),
        make_option("--fixef", help = "fixed effects terms", default = NULL),
        make_option("--intef", help = "fixed interaction effects terms", default = NULL),
        make_option("--ranef", help = "random effects terms", default = NULL),
        make_option("--prefilter", help = "only test pairs listed in this sqlite database", default = NULL),
        make_option("--genespos", help = "genes positions sqlite database", default = NULL),
        make_option("--snpspos", help = "snps positions sqlite database",  default = NULL),
        make_option("--cis-window", help = "cis window size [default: 5e5]", default = 5e5),
        make_option("--trans-pvalue", help = "trans p-value threshold [default: 1E-5]", default = 1e-5),
        make_option("--cis-pvalue", help = "cis p-value threshold [default: 0.1]", default = 0.1),
        make_option("--cores", help = "numbers of cores to use [default: 1]", default = 1),
        make_option("--max-regressions", help = "max number of regressions data to keep in memory at once [default: 10000]", default = 10000L),
        make_option("--regressors-chunk-size", help = "regressors reading chunk size [default: 1000]", default = 1000L)
        )

parser <- OptionParser(usage = "%prog [options]",
                       description = "random effects eqtls",
                       option_list = option_list)
opts <- parse_args(parser, positional_arguments = FALSE)

##
## check sanity of input options
##
with(opts, {
  if(regressors != "-") {
    stopifnot(file.exists(regressors))
  }
  stopifnot(file.exists(outcomes))
  if("fixef" %in% names(opts)) {
    stopifnot(file.exists(fixef))
  }
  if("intef" %in% names(opts)) {
    stopifnot(file.exists(intef))
  }
  stopifnot(file.exists(ranef))
  if("prefilter" %in% names(opts)) {
    stopifnot(file.exists(prefilter))
  }
  stopifnot(file.exists(genespos))
  stopifnot(file.exists(snpspos))
  stopifnot(`cis-window` >= 0)
  stopifnot(`cis-pvalue` >= 0)
  stopifnot(`trans-pvalue` >= 0)
  stopifnot(cores >= 1)
})

if(opts$cores > 1) suppressMessages({
  library(doMC)
  registerDoMC(cores = opts$cores)
})

sink(stderr())
str(opts)
sink()

db <- dbConnect(dbDriver("SQLite"), ":memory:")
ignore <- dbGetQuery(db, sprintf('attach "%s" as genesdb', opts$genespos))
ignore <- dbGetQuery(db, sprintf('attach "%s" as snpsdb', opts$snpspos))

if(opts$regressors == "-") {
  input <- file("stdin")
} else {
  input <- file(opts$regressors, open = "r", raw = TRUE)
}

message("reading outcomes data...")
outcomes.con <- file(opts$outcomes, open = "r", raw = TRUE)
outcomes <- read.table(file = outcomes.con,
                       sep = "\t",
                       header = FALSE,
                       quote = "",
                       comment.char = "",
                       colClasses = c("character", "character", "numeric"),
                       col.names = c("reporterID", "sampleID", "expression"))
close(outcomes.con)
message("done:")
sink(stderr())
str(outcomes)
sink()

formula.components <- list()

if(!is.null(opts$fixef)) {
  message("reading fixed effects data...")
  fc <- file(opts$fixef, "r")
  h <- readLines(fc, n = 1)
  pushBack(h, fc)
  fixef <- read.table(fc,
                      sep = "\t",
                      header = FALSE,
                      quote = "",
                      comment.char = "",
                      colClasses = c("character", rep(NA_character_, length(strsplit(h, "\t")[[1]]) - 1)))
  close(fc)
  names(fixef)[1] <- "sampleID"
  names(fixef)[-1] <- paste0("F", seq_len(length(fixef) - 1))
  if(length(fixef) > 1) {
    formula.components$fixef <- paste(names(fixef)[-1], collapse = " + ")
  }
  message("done:")
  sink(stderr())
  str(fixef)
  sink()
} else {
  fixef <- unique(subset(outcomes, select = sampleID))
}

message("reading random effects data...")
ranef <- read.table(opts$ranef,
                    sep = "\t",
                    header = FALSE,
                    quote = "",
                    comment.char = "",
                    colClasses = c("character", NA_character_))
names(ranef)[1] <- "sampleID"
names(ranef)[-1] <- paste0("R", seq_len(length(ranef) - 1))
formula.components$ranef <- paste(sprintf("(1 | %s)", names(ranef)[-1], collapse = " + "))
message("done:")
sink(stderr())
str(ranef)
sink()

message("merging covariates data...")
covariates <- merge(fixef, ranef, by = "sampleID")
sink(stderr())
str(covariates)
sink()

if(!is.null(opts$intef)) {
  DRIVER <- DRIVERS$INTERACTION
  message("reading interaction effects data...")
  intef <- read.table(opts$intef,
                      sep = "\t",
                      header = FALSE,
                      quote = "",
                      comment.char = "",
                      colClasses = c("character", NA_character_))
  names(intef)[1] <- "sampleID"
  names(intef)[-1] <- paste0("FI", seq_len(length(intef) - 1))
  formula.components$intef <- paste(paste("alleleCopyNumber * ",  names(intef)[-1], sep = ""), collapse = " + ")
  message("done:")
  sink(stderr())
  str(intef)
  sink()

  message("merging covariates data...")
  covariates <- merge(covariates, intef, by = "sampleID")
  sink(stderr())
  str(covariates)
  sink()
}

message("merging outcomes data...")
outcomes.c <- merge(outcomes, covariates, by = "sampleID")
outcomes.c <- outcomes.c[order(outcomes.c$reporterID), ]
sink(stderr())
str(outcomes.c)
sink()

if(!is.null(opts$prefilter)) {
  ignore <- dbGetQuery(db, sprintf('attach "%s" as filterdb', opts$prefilter))
  OC.vnames <- setdiff(names(outcomes.c), c("reporterID", "sampleID"))
  OC.vnames <- paste(paste("outc.", OC.vnames), collapse = ", ")
  prefilter.query <- sprintf("
SELECT
       gt.SNPID as SNPID, outc.reporterID as reporterID,
       gt.sampleID as sampleID, gt.alleleCopyNumber as alleleCopyNumber,
       %s
FROM
       gtinput as gt, outcinput as outc, filterdb.pairs as fp
WHERE
       gt.SNPID == fp.SNPID
       AND outc.reporterID == fp.reporterID
       AND gt.sampleID == outc.sampleID
", OC.vnames)

}

outcomes.sizes <- table(outcomes.c$reporterID)

splitItemsInto <- function(items.sizes, numPerPiece) {

  numItems <- length(items.sizes)
  numPerPiece <- max(ceiling(numPerPiece), 1)
  numPieces <- ceiling(numItems / numPerPiece)

  fuzz <- min((numItems - 1L) / 1000, 0.4 * numItems / numPieces)
  breaks <- seq(1 - fuzz, numItems + fuzz, length = numPieces + 1L)
  breaks <- breaks[-1]
  breaks[length(breaks)] <- numItems

  breaks <- floor(breaks)
  spans <- c(breaks[1], diff(breaks))
  f <- rep(seq_along(spans), spans)

  spans.expanded <- tapply(items.sizes, f, sum)
  breaks.expanded <- cumsum(spans.expanded)

  return(breaks.expanded)

}

##
## build formula
##
formula.str <- sprintf("expression ~ alleleCopyNumber + %s",
                       paste(as.vector(formula.components), collapse = " + "))
formula <- as.formula(formula.str)
message("model formula:")
sink(stderr())
print(formula)
sink()

if(!is.null(opts$intef)) {
  formula.baseline <- as.formula(gsub(" *\\* *FI[0-9]+", "", formula.str))
  message("baseline formula:")
  sink(stderr())
  print(formula.baseline)
  sink()
}

CHUNK_SIZE <- opts$`regressors-chunk-size`
readRegressor <- function(con) {

  ans <- data.frame(SNPID = character(0), sampleID = character(0), alleleCopyNumber = numeric(0),
                    stringsAsFactors = FALSE)

  repeat {

    txt <- readLines(con, CHUNK_SIZE, warn = FALSE)
    if(length(txt) == 0) {
      break
    }

    txtCon <- textConnection(txt)
    chunk <- read.table(txtCon,
                        sep = "\t",
                        header = FALSE,
                        quote = "",
                        comment.char = "",
                        colClasses = c("character", "character", "numeric"),
                        col.names = c("SNPID", "sampleID", "alleleCopyNumber"))

    if(nrow(ans) == 0) {
      ans <- chunk
      firstSNP <- head(ans$SNPID, 1)

      if(head(ans$SNPID, 1) == tail(ans$SNPID, 1)) {
        ## we're not done with this SNP: keep reading
        next
      }

      lastSNP <- tail(ans$SNPID, 1)
      keep.flag <- with(ans, SNPID != lastSNP)
      ans <- ans[keep.flag, ]
      pushBack(txt[!keep.flag], con)
      break
    }

    lastSNP <- tail(chunk$SNPID, 1)
    if(lastSNP != firstSNP) {
      keep.flag <- with(chunk, SNPID != lastSNP)
      ans <- rbind(ans, subset(chunk, keep.flag))
      pushBack(txt[!keep.flag], con)
      break
    }

    ans <- rbind(ans, chunk)

  }

  return(ans)
}

pvalue.max <- max(opts$`cis-pvalue`, opts$`trans-pvalue`)

##
## SQL BOOLEAN CONDITION FOR 'CIS' EFFECTS
##
cisCondition <- sprintf("((gtpos.chromosome == gexpos.chromosome)
    AND
    ((abs(gtpos.position - gexpos.start) <= %d)
     OR (abs(gtpos.position - gexpos.end) <= %d)
     OR (gtpos.position >= gexpos.start AND gtpos.position <= gexpos.end)))
", opts$`cis-window`, opts$`cis-window`)

filteringQuery <- sprintf('
  SELECT gexpos.reporterID as reporterID, gtpos.SNPID as SNPID, %s,
         CASE WHEN %s THEN "cis" ELSE "trans" END as isCis
  FROM snpsdb.snpspos as gtpos, genesdb.genespos as gexpos, results as rs
  WHERE gtpos.SNPID == rs.SNPID
  AND gexpos.reporterID == rs.reporterID
  AND
   (
    %s
    OR
     rs.pvalue <= %f
   )
',
                          paste(paste0(paste("rs", sep = ".", DRIVER$colnames), " as ", DRIVER$colnames), collapse = ", "),
                          cisCondition, cisCondition, opts$`trans-pvalue`)

##
## MAIN LOOP
##

TIME_INTERVAL <- as.difftime(15, units = "mins")
ORIG_TIME <- START_TIME <- Sys.time()
SNPs_COUNTER <- 0

## split up elapsed time into its components:
READING_TIME <- 0
JOINING_TIME <- 0
PROCESSING_TIME <- 0
FILTERING_TIME <- 0
WRITING_TIME <- 0
GC_TIME <- 0 ## garbage collection

printTimingInfo <- function() {
  message(SNPs_COUNTER, " regressors processed in ", format(CUR_TIME - ORIG_TIME))
  message(" reading input: ", format(READING_TIME))
  message(" joining data: ", format(JOINING_TIME))
  message(" processing: ", format(PROCESSING_TIME))
  message(" filtering output: ", format(FILTERING_TIME))
  message(" writing output: ", format(WRITING_TIME))
  message(" garbage collection: ", format(GC_TIME))
}

message("\n=> main loop started on ", date(), "\n")

repeat {

INIT_TICK <- Sys.time()

genotype <- readRegressor(input)

READING_TICK <- Sys.time()
READING_TIME <- READING_TIME + (READING_TICK - INIT_TICK)

if(nrow(genotype) == 0) {
  message("no more lines in input: terminating...")
  break
}

numRegressors <- length(unique(genotype$SNPID))
SNPs_COUNTER <- SNPs_COUNTER + numRegressors

outcomesBreaks <- splitItemsInto(outcomes.sizes, numPerPiece = opts$`max-regressions` / numRegressors )

outcomesRowCounter <- 0

for(outcomesBreak in outcomesBreaks) {

  BUCKING_TICK <- Sys.time()

  OC <- outcomes.c[seq(outcomesRowCounter + 1, outcomesBreak), ]

  if(!is.null(opts$prefilter)) {

    ignore <- dbWriteTable(db, name = "gtinput", genotype)
    ignore <- dbWriteTable(db, name = "outcinput", OC)
    data <- dbGetQuery(db, prefilter.query)
    ignore <- dbRemoveTable(db, "gtinput")
    ignore <- dbRemoveTable(db, "outcinput")

  } else {

    data <- merge(genotype, OC, by = "sampleID")

  }

  outcomesRowCounter <- outcomesBreak

  JOINING_TICK <- Sys.time()
  JOINING_TIME <- JOINING_TIME + (JOINING_TICK - BUCKING_TICK)

  results <- ddply(data, .(reporterID, SNPID), DRIVER$fitter, .parallel = opts$cores > 1)

  PROCESSING_TICK <- Sys.time()
  PROCESSING_TIME <- PROCESSING_TIME + (PROCESSING_TICK - JOINING_TICK)

  if(nrow(results) == 0) {
    next
  }

  ##
  ## tag cis and trans
  ##

  ignore <- dbWriteTable(db, name = "results", value = results)
  out <- dbGetQuery(db, filteringQuery)
  ignore <- dbRemoveTable(db, "results")

  FILTERING_TICK <- Sys.time()
  FILTERING_TIME <- FILTERING_TIME + (FILTERING_TICK - PROCESSING_TICK)

  ## message("writing to standard output...")
  write.table(out,
              row.names = FALSE,
              col.names = FALSE,
              sep = "\t",
              quote = FALSE)
  ## message("done.")

  WRITING_TICK <- Sys.time()
  WRITING_TIME <- WRITING_TIME + (WRITING_TICK - FILTERING_TICK)

  ignore <- gc()

  GC_TICK <- Sys.time()
  GC_TIME <- GC_TIME + (GC_TICK - WRITING_TICK)

  CUR_TIME <- Sys.time()
  ELAPSED <- CUR_TIME - START_TIME
  if(ELAPSED > TIME_INTERVAL) {
    START_TIME <- CUR_TIME
    printTimingInfo()
  }

} ## END GOING THROUGH BUCKETS OF OUTCOMES

} ## END REPEAT BLOCK

message("\n=> main loop completed on ", date(), "\n")

CUR_TIME <- Sys.time()
printTimingInfo()

ignore <- dbDisconnect(db)

message("analysis completed.")
