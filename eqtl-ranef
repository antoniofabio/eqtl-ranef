#!/usr/bin/env Rscript

suppressMessages({
  library(optparse)
  library(reshape)
  library(plyr)
  library(RSQLite)
  library(lme4)
})

option_list <-
    list(
        make_option("--regressors", help = "regressors data matrix file (use '-' for standard input)", default = NULL),
        make_option("--outcomes", help = "outcomes data matrix file", default = NULL),
        make_option("--fixef", help = "fixed effects terms", default = NULL),
        make_option("--ranef", help = "random effects terms", default = NULL),
        make_option("--genespos", help = "genes positions sqlite database", default = NULL),
        make_option("--snpspos", help = "snps positions sqlite database",  default = NULL),
        make_option("--cis-window", help = "cis window size [default: 5e5]", default = 5e5),
        make_option("--trans-pvalue", help = "trans p-value threshold [default: 1E-5]", default = 1e-5),
        make_option("--cis-pvalue", help = "cis p-value threshold [default: 0.1]", default = 0.1),
        make_option("--cores", help = "numbers of cores to use [default: 1]", default = 1),
        make_option("--max-regressions", help = "max number of regressions data to keep in memory at once [default: 10000]", default = 10000L)
        )

parser <- OptionParser(usage = "%prog [options] < genotype.thin.dose",
                       description = "random effects eqtls",
                       option_list = option_list)
opts <- parse_args(parser, positional_arguments = FALSE)

##
## check sanity of input options
##
with(opts, {
  if(regressors != "-") {
    stopifnot(file.exists(regressors))
  }
  stopifnot(file.exists(outcomes))
  stopifnot(file.exists(fixef))
  stopifnot(file.exists(ranef))
  stopifnot(file.exists(genespos))
  stopifnot(file.exists(snpspos))
  stopifnot(`cis-window` >= 0)
  stopifnot(`cis-pvalue` >= 0)
  stopifnot(`trans-pvalue` >= 0)
  stopifnot(cores >= 1)
})

if(opts$cores > 1) suppressMessages({
  library(doMC)
  registerDoMC(cores = opts$cores)
})

sink(stderr())
str(opts)
sink()

db <- dbConnect(dbDriver("SQLite"), ":memory:")
ignore <- dbGetQuery(db, sprintf('attach "%s" as genesdb', opts$genespos))
ignore <- dbGetQuery(db, sprintf('attach "%s" as snpsdb', opts$snpspos))

if(opts$regressors == "-") {
  input <- file("stdin")
} else {
  input <- file(opts$regressors, open = "r", raw = TRUE)
}

message("reading outcomes data...")
outcomes.con <- file(opts$outcomes, open = "r", raw = TRUE)
outcomes <- read.table(file = outcomes.con,
                       sep = "\t",
                       header = FALSE,
                       quote = "",
                       comment.char = "",
                       colClasses = c("character", "character", "numeric"),
                       col.names = c("reporterID", "sampleID", "expression"))
close(outcomes.con)
message("done:")
sink(stderr())
str(outcomes)
sink()

message("reading fixed effects data...")
fixef <- read.table(opts$fixef,
                    sep = "\t",
                    header = FALSE,
                    quote = "",
                    comment.char = "",
                    colClasses = c("character", NA_character_))
names(fixef)[1] <- "sampleID"
names(fixef)[-1] <- paste0("F", seq_len(length(fixef) - 1))
message("done:")
sink(stderr())
str(fixef)
sink()

message("reading random effects data...")
ranef <- read.table(opts$ranef,
                    sep = "\t",
                    header = FALSE,
                    quote = "",
                    comment.char = "",
                    colClasses = c("character", NA_character_))
names(ranef)[1] <- "sampleID"
names(ranef)[-1] <- paste0("R", seq_len(length(ranef) - 1))
message("done:")
sink(stderr())
str(ranef)
sink()

message("merging covariates data...")
covariates <- merge(fixef, ranef, by = "sampleID")
sink(stderr())
str(covariates)
sink()

message("merging outcomes data...")
outcomes.c <- merge(outcomes, covariates, by = "sampleID")
sink(stderr())
str(outcomes.c)
sink()

##
## MODEL FITTING FUNCTION
##
fitter <- function(dat) {
  out <- coefficients(summary(lmer(formula, data = dat)))["alleleCopyNumber",, drop = FALSE]
  tValue <- out[, "t value"]
  subset(data.frame(pvalue = 2 * pnorm(abs(tValue), lower.tail = FALSE),
                    beta = out[, "Estimate"],
                    t = tValue,
                    nobs = nrow(dat)),
         pvalue <= pvalue.max)
}

allOutcomes <- unique(outcomes.c$reporterID)

splitItemsInto <- function(items, numPerPiece) {

  numItems <- length(items)
  numPerPiece <- max(ceiling(numPerPiece), 1)
  numPieces <- ceiling(numItems / numPerPiece)

  fuzz <- min((numItems - 1L) / 1000, 0.4 * numItems / numPieces)
  breaks <- seq(1 - fuzz, numItems + fuzz, length = numPieces + 1L)
  breaks <- breaks[-1]
  breaks[length(breaks)] <- numItems

  breaks <- floor(breaks)
  spans <- c(breaks[1], diff(breaks))
  f <- rep(seq_along(spans), spans)

  return(split(items, f))

}

##
## build formula
##
formula.fixef <- paste(names(fixef)[-1], collapse = " + ")
formula.ranef <- paste(sprintf("(1 | %s)", names(ranef)[-1]), collapse = " + ")
formula.str <- sprintf("expression ~ alleleCopyNumber + %s + %s", formula.fixef, formula.ranef)
formula <- as.formula(formula.str)
message("model formula:")
sink(stderr())
print(formula)
sink()

CHUNK_SIZE <- 1000L
readRegressor <- function(con) {
  ans <- data.frame(SNPID = character(0), sampleID = character(0), alleleCopyNumber = numeric(0),
                    stringsAsFactors = FALSE)

  repeat {
    txt <- readLines(con, CHUNK_SIZE, warn = FALSE)
    if(length(txt) == 0) {
      break
    }

    txtCon <- textConnection(txt)
    chunk <- read.table(txtCon,
                        sep = "\t",
                        header = FALSE,
                        quote = "",
                        comment.char = "",
                        colClasses = c("character", "character", "numeric"),
                        col.names = c("SNPID", "sampleID", "alleleCopyNumber"))
    lastSeenSNP <- tail(chunk$SNPID, 1)
    if(chunk$SNPID[1] != lastSeenSNP) {
      keep.flag <- with(chunk, SNPID != lastSeenSNP)
      ans <- rbind(ans, subset(chunk, keep.flag))
      pushBack(txt[!keep.flag], con)
      break
    }
    ans <- rbind(ans, chunk)
  }

  return(ans)
}

pvalue.max <- max(opts$`cis-pvalue`, opts$`trans-pvalue`)

##
## SQL BOOLEAN CONDITION FOR 'CIS' EFFECTS
##
cisCondition <- sprintf("((gtpos.chromosome == gexpos.chromosome)
    AND
    ((abs(gtpos.position - gexpos.start) <= %d)
     OR (abs(gtpos.position - gexpos.end) <= %d)
     OR (gtpos.position >= gexpos.start AND gtpos.position <= gexpos.end)))
", opts$`cis-window`, opts$`cis-window`)

filteringQuery <- sprintf('
  SELECT gexpos.reporterID as reporterID, gtpos.SNPID as SNPID, rs.pvalue as pvalue, rs.beta as beta, rs.t as t, rs.nobs as nobs,
         CASE WHEN %s THEN "cis" ELSE "trans" END as isCis
  FROM snpsdb.snpspos as gtpos, genesdb.genespos as gexpos, results as rs
  WHERE gtpos.SNPID == rs.SNPID
  AND gexpos.reporterID == rs.reporterID
  AND
   (
    %s
    OR
     rs.pvalue <= %f
   )
', cisCondition, cisCondition, opts$`trans-pvalue`)

##
## MAIN LOOP
##

TIME_INTERVAL <- as.difftime(15, units = "mins")
ORIG_TIME <- START_TIME <- Sys.time()
SNPs_COUNTER <- 0

## split up elapsed time into its components:
READING_TIME <- 0
JOINING_TIME <- 0
PROCESSING_TIME <- 0
FILTERING_TIME <- 0
WRITING_TIME <- 0
GC_TIME <- 0 ## garbage collection

printTimingInfo <- function() {
  message(SNPs_COUNTER, " regressors processed in ", format(CUR_TIME - ORIG_TIME))
  message(" reading input: ", format(READING_TIME))
  message(" joining data: ", format(JOINING_TIME))
  message(" processing: ", format(PROCESSING_TIME))
  message(" filtering output: ", format(FILTERING_TIME))
  message(" writing output: ", format(WRITING_TIME))
  message(" garbage collection: ", format(GC_TIME))
}

message("\n=> main loop started on ", date(), "\n")

repeat {

INIT_TICK <- Sys.time()

genotype <- readRegressor(input)

READING_TICK <- Sys.time()
READING_TIME <- READING_TIME + (READING_TICK - INIT_TICK)

if(nrow(genotype) == 0) {
  message("no more lines in input: terminating...")
  break
}

numRegressors <- length(unique(genotype$SNPID))
SNPs_COUNTER <- SNPs_COUNTER + numRegressors

buckets <-
    splitItemsInto(items = allOutcomes,
                   numPerPiece = length(allOutcomes) * numRegressors / opts$`max-regressions`)

for(bucket in buckets) {

  BUCKING_TICK <- Sys.time()

  data <- merge(genotype,
                subset(outcomes.c, reporterID %in% bucket),
                by = "sampleID")

  JOINING_TICK <- Sys.time()
  JOINING_TIME <- JOINING_TIME + (JOINING_TICK - BUCKING_TICK)

  results <- ddply(data, .(reporterID, SNPID), fitter, .parallel = opts$cores > 1)

  PROCESSING_TICK <- Sys.time()
  PROCESSING_TIME <- PROCESSING_TIME + (PROCESSING_TICK - JOINING_TICK)

  if(nrow(results) == 0) {
    next
  }

  ##
  ## tag cis and trans
  ##

  ignore <- dbWriteTable(db, name = "results", value = results)
  out <- dbGetQuery(db, filteringQuery)
  ignore <- dbRemoveTable(db, "results")

  FILTERING_TICK <- Sys.time()
  FILTERING_TIME <- FILTERING_TIME + (FILTERING_TICK - PROCESSING_TICK)

  ## message("writing to standard output...")
  write.table(out,
              row.names = FALSE,
              col.names = FALSE,
              sep = "\t",
              quote = FALSE)
  ## message("done.")

  WRITING_TICK <- Sys.time()
  WRITING_TIME <- WRITING_TIME + (WRITING_TICK - FILTERING_TICK)

  ignore <- gc()

  GC_TICK <- Sys.time()
  GC_TIME <- GC_TIME + (GC_TICK - WRITING_TICK)

  CUR_TIME <- Sys.time()
  ELAPSED <- CUR_TIME - START_TIME
  if(ELAPSED > TIME_INTERVAL) {
    START_TIME <- CUR_TIME
    printTimingInfo()
  }

} ## END GOING THROUGH BUCKETS OF OUTCOMES

} ## END REPEAT BLOCK

message("\n=> main loop completed on ", date(), "\n")

CUR_TIME <- Sys.time()
printTimingInfo()

ignore <- dbDisconnect(db)

message("analysis completed.")
